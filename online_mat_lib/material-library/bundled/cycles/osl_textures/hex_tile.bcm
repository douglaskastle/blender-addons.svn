<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="OUTPUT_MATERIAL" loc="253, 327" />
		<node type="SCRIPT" mode="INTERNAL" script="0" coord="Vector(0.0, 0.0, 0.0)" ka="0.5" kd="0.5" ks="0.20000" roughness="0.10000" specularcolor="rgba(1.0, 1.0, 1.0, 1.0)" tilecolor="rgba(0.55000, 0.0, 0.0, 1.0)" mortarcolor="rgba(0.5, 0.5, 0.5, 1.0)" tileradius="0.20000" mortarwidth="0.01999" tilevary="0.15000" scuffing="0.5" stains="0.40000" stainfrequency="2.0" scufffrequency="4.0" scuffcolor="rgba(0.05000, 0.05000, 0.05000, 1.0)" loc="-69, 387" />
	</nodes>
	<links>
		<link to="0" input="0" from="1" output="0" />
	</links>
	<scripts>
		<script name="hex_tile.osl" id="0">
/*<br /> * {converted/hacked to OSL from http://www.renderman.org/RMR/Shaders/LGShaders/LGHexTile.sl}<br /> * hextile.sl -- surface shader for hexagonal tiles in st space<br /> *<br /> * DESCRIPTION<br /> *       This surface shader operates in s-t space and gives a pattern of<br /> *    hexagonal tiles, similar to that found as floor patterns in public<br /> *    places and such.<br /> *       The basic pattern is a hexagonal tiling, with a little bit of<br /> *    color variation from tile to tile.  On top of that is some staining<br /> *    (presumably due to water or something), which darkens the tile or<br /> *    mortar underneath it.  Finally, there is scuffing due to people's<br /> *    shoes, which really only affects the tile part not the mortar part.<br /> *<br /> *<br /> * PARAMTERS<br /> *    Ka, Kd, Ks, roughness, specularcolor - work just like plastic<br /> *    tilecolor - the color of the tiles<br /> *    mortarcolor - the color of the mortar (space between the tiles)<br /> *    tileradius - the &quot;radius&quot; (in s-t units) of a single tile<br /> *    mortarwidth - the width of the mortar (in s-t units)<br /> *    tilevary - the color variance from tile to tile<br /> *<br /> * ANTIALIASING<br /> *    Some rudimentary antialiasing is performed on the borders between<br /> *    tile and mortar.<br /> *<br /> * HINTS &amp; APPLICATIONS<br /> *    If all of the default parameters are used, the tiles look just like<br /> *    the floors in the public areas of the Washington DC subway system.<br /> *<br /> * AUTHOR: written by Larry Gritz, 1994<br /> *<br /> * HISTORY:<br /> *    15 Feb 1994 -- written by lg<br /> *<br /> * last modified 15 Feb 94 by Larry Gritz<br /> */<br /><br />shader<br />LGHexTile (<br />    point coord = P,<br />    float Ka = .5,<br />    float Kd = .5,<br />    float Ks = .2,<br />    float roughness = .1,<br />    color specularcolor = 1,<br />    color tilecolor = color(.55,0,0),<br />    color mortarcolor = color(.5,.5,.5),<br />    float tileradius = 0.2,<br />    float mortarwidth = 0.02,<br />    float tilevary = 0.15,<br />    float scuffing = 0.5,<br />    float stains = 0.4,<br />    float stainfrequency = 2,<br />    float scufffrequency = 4,<br />    color scuffcolor = color (.05,.05,.05),<br />    output closure color Closure = diffuse(N)<br />)<br />{<br />    #define snoise(x) (2*noise(x)-1)<br />    #define snoise2(x,y) (2*noise((x),(y))-1)<br />    #define MINFILTERWIDTH 1.0e-7<br />    #define M_SQRT3 1.7320508 /* sqrt(3) */<br />    <br />    point Nf;<br />    color Ct, Ctile;<br />    float tilewidth;<br />    float ss, tt;<br />    float ttile, stile;<br />    float x, y;<br />    float mortar;<br />    float swidth, twidth, sfuzz, tfuzz, fuzzmax;<br />    float mw2, mw2srt3;<br />    float tileindex;<br />    float stain, scuff;<br />    float ks;<br /><br />    float s = coord[0];<br />    float t = coord[1];<br /><br />    swidth = abs(Dx(s)) + abs(Dy(s));<br />    twidth = abs(Dx(t)) + abs(Dy(t));<br />    sfuzz = 0.5 * swidth;<br />    tfuzz = 0.5 * twidth;<br />    fuzzmax = max(sfuzz, tfuzz);<br />    Nf = N;<br /><br />    tilewidth = tileradius * M_SQRT3;  <br />    tt = mod (t, 1.5*tileradius);<br />    ttile = floor(t/(1.5*tileradius));<br />    if (mod(ttile/2, 1) == 0.5)<br />       ss = s + tilewidth/2;<br />    else ss = s;<br />    stile = floor(ss / tilewidth);<br />    ss = mod(ss, tilewidth);<br />    mortar = 0;<br />    mw2 = mortarwidth/2;<br />    if (tt &lt; tileradius) {<br />      mortar =  1 - (smoothstep(mw2,mw2+sfuzz,ss) *<br />             (1 - smoothstep(tilewidth-mw2-sfuzz,tilewidth-mw2,ss)));<br />    }<br />    else {<br />      x = tilewidth/2 - abs(ss - tilewidth/2);<br />      y = M_SQRT3 * (tt - tileradius);<br />      if (y &gt; x) {<br />      if (mod (ttile/2, 1) == 0.5)<br />          stile -= 1;<br />      ttile += 1;<br />      if (ss &gt; tilewidth/2)<br />          stile += 1;<br />    }<br /><br />        mw2srt3 = M_SQRT3*mw2;<br />        mortar = (smoothstep(x-mw2srt3-tfuzz, x-mw2srt3, y) *<br />            (1 - smoothstep(x+mw2srt3, x+mw2srt3+tfuzz, y)));<br />    }<br /><br />    tileindex = stile+41*ttile;<br />    Ctile = tilecolor * (1 + tilevary * snoise(tileindex+0.5));<br /><br />    stain = stains * smoothstep (.5,1, noise(s*stainfrequency,t*stainfrequency));<br /><br />    scuff = scuffing * smoothstep (.6,1, noise(t*scufffrequency-90.26,s*scufffrequency+123.82));<br /><br />    ks = Ks * (1-scuff/2);<br />    Ct = (1-stain) * mix(mix(Ctile, scuffcolor, scuff), mortarcolor, mortar);<br />      // Oi = Os;<br />      // Nf = faceforward (normalize(N),I);<br />      // Ci = Os * ( Ct * (Ka*ambient() + Kd*diffuse(Nf)) +<br />              // specularcolor * ks*specular(Nf,-normalize(I),roughness));<br />    Nf = normalize(N); //no faceforward function<br />    Closure = Ct*Kd*diffuse(Nf); //no aambient function<br />    Closure += specularcolor*ks*microfacet_beckmann(Nf,roughness);         <br />}
		</script>
	</scripts>
</material>